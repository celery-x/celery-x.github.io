<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>spring的启动流程</title>
    <link href="/2023/03/27/spring/spring%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/03/27/spring/spring%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="以ClassPathXmlApplicationContext为例，启动流程"><a href="#以ClassPathXmlApplicationContext为例，启动流程" class="headerlink" title="以ClassPathXmlApplicationContext为例，启动流程"></a>以ClassPathXmlApplicationContext为例，启动流程</h1><p><img src="/img/spring/springstart1.png"></p><h4 id="1-设置父容器-2-将路径缓存下来-3-进入ApplicationContext的核心逻辑refrsh"><a href="#1-设置父容器-2-将路径缓存下来-3-进入ApplicationContext的核心逻辑refrsh" class="headerlink" title="1.设置父容器 2.将路径缓存下来 3.进入ApplicationContext的核心逻辑refrsh"></a>1.设置父容器 2.将路径缓存下来 3.进入ApplicationContext的核心逻辑refrsh</h4><p><img src="/img/spring/springstart2.png"></p><h4 id="进行xml的读取"><a href="#进行xml的读取" class="headerlink" title="进行xml的读取"></a>进行xml的读取</h4><p>关键的调用为：ClassPathXmlApplicationContext#ClassPathXmlApplicationContext. —→ AbstractApplicationContext#refresh —→ AbstractXmlApplicationContext#loadBeanDefinitions</p><p>而后委托给 org.springframework.beans.factory.xml.XmlBeanDefinitionReader 进行xml的读取</p><p><img src="/img/spring/springstart3.png"></p><p>而后进行准备工作，忽略aware的自动注入，将自己注册进去。</p><p><img src="/img/spring/springstart4.png"></p><p>这是一个空方法，留给用户扩展。</p><p><img src="/img/spring/springstart5.png"></p><h4 id="激活BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor"><a href="#激活BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor" class="headerlink" title="激活BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor"></a>激活BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor</h4><p>方便阅读下文</p><p>BeanFactoryPostProcessor –→ pp</p><p>BeanDefinitionRegistryPostProcessor —→ Rpp</p><p>一些常用的注解的处理就是在此处，比如@Configuration</p><p><img src="/img/spring/springstart6.png"></p><p>先执行postProcessBeanDefinitionRegistry</p><p>具体的执行逻辑是先执行context中已存在的Rpp Bean (初始为空)</p><p>然后执行实现PriorityOrdered接口的Rpp BeanDefinition（先getBean生成bean）</p><p>然后是实现Ordered接口的Rpp BeanDefinition（先getBean生成bean）</p><p>最后是其他的Rpp BeanDefinition（先getBean生成bean）</p><p>然后是刚刚执行的所有Rpp的postProcessBeanFactory方法，以及context原本存在的pp的postProcessBeanFactory</p><p>而后处理pp</p><p>跟Rpp类似，但会排除已执行的Rpp，因为Rpp继承与pp</p><p>PriorityOrdered-&gt;Ordered→普通</p><h4 id="注册创建bean的时候的处理器"><a href="#注册创建bean的时候的处理器" class="headerlink" title="注册创建bean的时候的处理器"></a>注册创建bean的时候的处理器</h4><p>与上述类似注册BeanPostProcessor</p><p>PriorityOrdered→Ordered→普通</p><p>不同的是，如果是MergedBeanDefinitionPostProcessor，会按照上述逻辑注册一次后，在最后再注册一次，并移除之前注册的，即最后执行这些</p><p><img src="/img/spring/springstart7.png"></p><h4 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h4><p>略</p><h4 id="初始化广播器"><a href="#初始化广播器" class="headerlink" title="初始化广播器"></a>初始化广播器</h4><p>如果用户没有配置，使用SimpleApplicationEventMulticaster</p><p>会遍历所有监听器，调用监听方法</p><h4 id="onRefresh方法，扩展点，无默认实现"><a href="#onRefresh方法，扩展点，无默认实现" class="headerlink" title="onRefresh方法，扩展点，无默认实现"></a>onRefresh方法，扩展点，无默认实现</h4><h4 id="注册监听器"><a href="#注册监听器" class="headerlink" title="注册监听器"></a>注册监听器</h4><p>同上述一样，从beanFactory中遍历所有ApplicationListener初始化</p><p>然后会检测一下当前事件列表是否有事件，如果有会立刻触发一次监听</p><p><img src="/img/spring/springstart8.png"></p><h4 id="收尾事项"><a href="#收尾事项" class="headerlink" title="收尾事项"></a>收尾事项</h4><p>1.ConversionService配置，用于提供Converter功能，一些常见的类型转化服务</p><p>2.LTW支持–没研究。</p><p>3.冻结所有bean的定义信息，不会修改meta</p><p>4.初始化所有非延迟加载实例</p><h4 id="完成启动"><a href="#完成启动" class="headerlink" title="完成启动"></a>完成启动</h4><p><img src="/img/spring/springstart9.png"></p><p>1.清理一些资源缓存</p><p>2.初始化LifecycleProcessor，会在各个阶段更新实现Lifecycle的bean的状态</p><p>3.启动所有Lifecycle</p><p>4.发布刷新完成通知</p><p>5.给Spring Tool Suite做准备 </p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo的SPI机制</title>
    <link href="/2023/03/27/dubbo/dubbo%E7%9A%84SPI%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/03/27/dubbo/dubbo%E7%9A%84SPI%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>dubbo的spi机制有3中获取方式</p><p>ExtensionLoader.getExtensionLoader(xxx.class).getAdaptiveExtension();<br>ExtensionLoader.getExtensionLoader(xxx.class).getExtension(name);<br>ExtensionLoader.getExtensionLoader(xxx.class).getActivateExtension(url, key);</p><h1 id="1-getExtension"><a href="#1-getExtension" class="headerlink" title="1.getExtension"></a>1.getExtension</h1><p>最简单直接的一种，直接通过传递过来的参数，获取对应的class加载</p><p><img src="/img/dubbo/spi1.png"></p><p>底层通过读取资源文件，获取class名后反射获取</p><p><img src="/img/dubbo/spi2.png"></p><h1 id="2-getAdaptiveExtension"><a href="#2-getAdaptiveExtension" class="headerlink" title="2.getAdaptiveExtension"></a>2.getAdaptiveExtension</h1><p>第一步加载所有扩展的class</p><p><img src="/img/dubbo/spi3.png"></p><p>如果@Adaptive修饰类</p><p><img src="/img/dubbo/spi4.png"></p><p>会在加载时缓存该类，调用getAdaptiveExtension时会直接返回该类。</p><p>如果修饰方法：</p><p>而后生成一个代理</p><p><img src="/img/dubbo/spi5.png"></p><p>比如说</p><p>ExtensionLoader.getExtensionLoader(RouterFactory.class).getAdaptiveExtension()</p><p>注解在接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Adaptive(&quot;protocol&quot;)</span><br>Router <span class="hljs-title function_">getRouter</span><span class="hljs-params">(URL url)</span>;<br></code></pre></td></tr></table></figure><p>会生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.dubbo.rpc.cluster;<br><span class="hljs-keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RouterFactory$Adaptive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">org</span>.apache.dubbo.rpc.cluster.RouterFactory &#123;<br><span class="hljs-keyword">public</span> org.apache.dubbo.rpc.cluster.Router <span class="hljs-title function_">getRouter</span><span class="hljs-params">(org.apache.dubbo.common.URL arg0)</span>  &#123;<br><span class="hljs-keyword">if</span> (arg0 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;url == null&quot;</span>);<br>org.apache.dubbo.common.<span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> arg0;<br><span class="hljs-type">String</span> <span class="hljs-variable">extName</span> <span class="hljs-operator">=</span> url.getProtocol();<br><span class="hljs-keyword">if</span>(extName == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Failed to get extension (org.apache.dubbo.rpc.cluster.RouterFactory) name from url (&quot;</span> + url.toString() + <span class="hljs-string">&quot;) use keys([protocol])&quot;</span>);<br>org.apache.dubbo.rpc.cluster.<span class="hljs-type">RouterFactory</span> <span class="hljs-variable">extension</span> <span class="hljs-operator">=</span> (org.apache.dubbo.rpc.cluster.RouterFactory)ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.RouterFactory.class).getExtension(extName);<br><span class="hljs-keyword">return</span> extension.getRouter(arg0);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当调用接口的getRouter方法时,底层调用的是生成的RouterFactory$Adaptive的getRouter方法,方法逻辑很简单，就是获取URL的protocol</p><p>即会生成一个代理，运行时才决定使用什么类</p><h1 id="3-getActivateExtension"><a href="#3-getActivateExtension" class="headerlink" title="3.getActivateExtension"></a>3.getActivateExtension</h1><p>跟上述的主动方变了，而且是加载一系列class</p><p>此处是class上的@Activate注解来选择是否加载，而非参数决定加载哪些class</p><p>比如传入group&#x3D;provider那么只在服务提供方才会加载这个class</p><p><img src="/img/dubbo/spi6.png"></p><p>比如Filter，就会在构建时传入对应的group</p><p><img src="/img/dubbo/spi7.png"></p><p>其中，注解中的value会从url中取k-v</p><p><img src="/img/dubbo/spi8.png"></p>]]></content>
    
    
    <categories>
      
      <category>dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring的bean创建流程</title>
    <link href="/2023/03/23/spring/spring%E7%9A%84bean%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/03/23/spring/spring%E7%9A%84bean%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-触发入口"><a href="#1-触发入口" class="headerlink" title="1.触发入口"></a>1.触发入口</h1><p>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</p><p>各种BeanFactory的getBean方法，如果还没创建过，就会进行创建流程</p><h1 id="2-主要流程"><a href="#2-主要流程" class="headerlink" title="2.主要流程"></a>2.主要流程</h1><h2 id="1-给BeanPostProcessors一个机会返回一个代理，不进行后续流程"><a href="#1-给BeanPostProcessors一个机会返回一个代理，不进行后续流程" class="headerlink" title="1.给BeanPostProcessors一个机会返回一个代理，不进行后续流程"></a>1.给BeanPostProcessors一个机会返回一个代理，不进行后续流程</h2><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</p><p><img src="/img/spring/beancreat1.png"></p><h2 id="2-实例化"><a href="#2-实例化" class="headerlink" title="2.实例化"></a>2.实例化</h2><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p><p><img src="/img/spring/beancreat2.png"></p><h2 id="3-触发后置处理器，进行元数据填充比如注解处理之类的"><a href="#3-触发后置处理器，进行元数据填充比如注解处理之类的" class="headerlink" title="3.触发后置处理器，进行元数据填充比如注解处理之类的"></a>3.触发后置处理器，进行元数据填充比如注解处理之类的</h2><p><img src="/img/spring/beancreat3.png"></p><h2 id="4-提前暴露当前bean的工厂"><a href="#4-提前暴露当前bean的工厂" class="headerlink" title="*4.提前暴露当前bean的工厂"></a>*4.提前暴露当前bean的工厂</h2><p><img src="/img/spring/beancreat4.png"></p><h2 id="5-填充依赖、初始化"><a href="#5-填充依赖、初始化" class="headerlink" title="5.填充依赖、初始化"></a>5.填充依赖、初始化</h2><h3 id="依赖填充"><a href="#依赖填充" class="headerlink" title="依赖填充"></a>依赖填充</h3><p><img src="/img/spring/beancreat5.png"></p><p>此处在处理依赖时，可能会去初始化其他bean，如果该bean也依赖于当前bean，那么就产生了循环依赖。</p><p>在spring中，处理循环依赖的方式是：提前暴露实例，后续bean依赖当前bean的话，可以直接引用实例化的当前bean</p><p><img src="/img/spring/beancreat6.png"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="/img/spring/beancreat7.png"></p><p>1.aware接口方法执行</p><p>2.后置处理的before方法(@PostConstruct在此处处理 org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization)</p><p>3.init-method</p><p>4.后置处理器的after方法</p><h3 id="循环依赖判断（无论是否出现循环依赖，都保证如果有动态代理，返回的是代理对象，保证AOP功能）"><a href="#循环依赖判断（无论是否出现循环依赖，都保证如果有动态代理，返回的是代理对象，保证AOP功能）" class="headerlink" title="循环依赖判断（无论是否出现循环依赖，都保证如果有动态代理，返回的是代理对象，保证AOP功能）"></a>循环依赖判断（无论是否出现循环依赖，都保证如果有动态代理，返回的是代理对象，保证AOP功能）</h3><p>spirng设计理念：代理对象尽量在原对象生成完毕后在生成。</p><p>但是如果出现了循环依赖，就不得不打破这个理念，提前生成代理对象。</p><p>代理对象生成时机有两个，分别对应是否有循环依赖：</p><p>1.有循环依赖，且是被提前暴露的那个：在别的对象从三级缓存中拿到factory进行getBean时，会执行AbstractAutoProxyCreator#<strong>getEarlyBeanReference，此方法会记录下bean → proxy的映射（用于最后的判断）</strong></p><p>2.无循环依赖，或有循环依赖，但不需要被引用提前暴露：会在后置处理器的after方法中进行代理AbstractAutoProxyCreator**#postProcessAfterInitialization**</p><p><img src="/img/spring/beancreat8.png"></p><p><strong>判断先判断是否提前生成了代理，如果没生成，那第一个 判断就是null，会直接跳出</strong></p><p><strong>如果生成了，就会去判断，是否此时的bean经过后置处理器后，还是原来的bean，如果不是了，就要判断是否有循环依赖：别的bean中注入的当前bean是否和最终的当前bean一致，不一致就会抛出异常</strong></p><p><strong>说人话就是：A最终生成的A-proxy，但是B中通过提前暴露获取到的是A-proxy0，就会抛异常</strong></p><p>此处有个tips：那么A经过提前暴露生成代理，又通过后置处理器再生成代理吗？ 并不会，前文的<strong>bean → proxy</strong> 映射，会在再次进入AbstractAutoProxyCreator时判断，存在映射的话，就不会再执行一次了</p><h1 id="为什么要用三级缓存？"><a href="#为什么要用三级缓存？" class="headerlink" title="为什么要用三级缓存？"></a>为什么要用三级缓存？</h1><p>其实我一直觉得这个问题问法有问题，如果指的是技术实现上，实际可以使用一层缓存，将不同种类的缓存分清即可，只不过会多很多的逻辑。</p><p>我觉得这个问题应该是：为什么spring解决循环依赖使用了两个bean中间态？（第一层缓存存的是生成完毕的bean，无论是否循环依赖都会有）</p><p>1.第二层缓存中的中间态：解决循环依赖</p><p>2.第三次缓存中的中间态：解决AOP生成代理，或者准确来说，实现能尽量保证代理生成晚于bean的生成。因为如果将代理生成提前，那么是可以不要这一层缓存的。</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo配置获取地</title>
    <link href="/2023/03/22/dubbo/dubbo%E9%85%8D%E7%BD%AE%E8%8E%B7%E5%8F%96%E5%9C%B0/"/>
    <url>/2023/03/22/dubbo/dubbo%E9%85%8D%E7%BD%AE%E8%8E%B7%E5%8F%96%E5%9C%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="配置来源"><a href="#配置来源" class="headerlink" title="配置来源"></a>配置来源</h1><p><img src="/img/dubbo/%E9%85%8D%E7%BD%AE%E6%9D%A5%E6%BA%901.png"></p><p>0.System.getProperties()</p><p>1.System.getEnv()</p><p>2.3.config-center</p><p>4.当前BeanConfig的meta,例如consumerConfig中的一些属性，在对该consumer刷新时会有对应key</p><p>5.dubbo.properties中的配置</p><p><img src="/img/dubbo/%E9%85%8D%E7%BD%AE%E6%9D%A5%E6%BA%902.png"></p><p>2.3一个是全局config-center配置 一个是应用 config-center的配置</p><p>此处配置是用来刷新的，不通过spring生成bean。</p><h1 id="远端配置中心配置的加载时机"><a href="#远端配置中心配置的加载时机" class="headerlink" title="远端配置中心配置的加载时机"></a>远端配置中心配置的加载时机</h1><p>在：org.apache.dubbo.config.bootstrap.DubboBootstrap#startConfigCenter</p><p><img src="/img/dubbo/%E9%85%8D%E7%BD%AE%E6%9D%A5%E6%BA%903.png"></p><p>在此处会将config-center中的配置置入environment<br>然后执行refresh</p><p>spring初始化bean</p><p>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</p><p><img src="/img/dubbo/%E9%85%8D%E7%BD%AE%E6%9D%A5%E6%BA%904.png"></p>]]></content>
    
    
    <categories>
      
      <category>dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo配置的来源</title>
    <link href="/2023/03/09/dubbo/dubbo%E9%85%8D%E7%BD%AE%E7%9A%84%E6%9D%A5%E6%BA%90/"/>
    <url>/2023/03/09/dubbo/dubbo%E9%85%8D%E7%BD%AE%E7%9A%84%E6%9D%A5%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="以dubbo-provider-parameters为例子"><a href="#以dubbo-provider-parameters为例子" class="headerlink" title="以dubbo.provider.parameters为例子"></a>以dubbo.provider.parameters为例子</h1><h3 id="服务暴露时组装时机："><a href="#服务暴露时组装时机：" class="headerlink" title="服务暴露时组装时机："></a>服务暴露时组装时机：</h3><p>org.apache.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol<br><img src="/img/dubbo/%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E7%BB%84%E8%A3%85%E5%8F%82%E6%95%B0.png"></p><p>在这里会拿到provider配置，将parameters获取到。</p><h3 id="所以问题就成了，如何配置，会被加载到ProviderConfig的bean中。"><a href="#所以问题就成了，如何配置，会被加载到ProviderConfig的bean中。" class="headerlink" title="所以问题就成了，如何配置，会被加载到ProviderConfig的bean中。"></a>所以问题就成了，如何配置，会被加载到ProviderConfig的bean中。</h3><h3 id="1-springboot自动注入"><a href="#1-springboot自动注入" class="headerlink" title="1.springboot自动注入"></a>1.springboot自动注入</h3><h4 id="dubbo-provider-parameters-key-x3D-value-或者-dubbo-provider-parameters-key-x3D-value-，不可使用dubbo-provider-parameters-x3D-jcfg-ok-，spring不会解析这个value"><a href="#dubbo-provider-parameters-key-x3D-value-或者-dubbo-provider-parameters-key-x3D-value-，不可使用dubbo-provider-parameters-x3D-jcfg-ok-，spring不会解析这个value" class="headerlink" title="dubbo.provider.parameters.key&#x3D;value 或者 dubbo.provider.parameters[key]&#x3D;value ，不可使用dubbo.provider.parameters&#x3D;[{jcfg:ok}]，spring不会解析这个value"></a>dubbo.provider.parameters.key&#x3D;value 或者 dubbo.provider.parameters[key]&#x3D;value ，不可使用dubbo.provider.parameters&#x3D;[{jcfg:ok}]，spring不会解析这个value</h4><p>在org.springframework.boot.bind.PropertiesConfigurationFactory中可以看见</p><h3 id="2-使用-DubboReference注解配置patameters属性"><a href="#2-使用-DubboReference注解配置patameters属性" class="headerlink" title="2.使用@DubboReference注解配置patameters属性"></a>2.使用@DubboReference注解配置patameters属性</h3><p>dubbo注解解析器：</p><p>org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor</p><p>会将注解配置读取</p><h3 id="3-jvm配置"><a href="#3-jvm配置" class="headerlink" title="3.jvm配置"></a>3.jvm配置</h3><h5 id="配置方式：dubbo-provider-parameters-x3D-key-value"><a href="#配置方式：dubbo-provider-parameters-x3D-key-value" class="headerlink" title="配置方式：dubbo.provider.parameters&#x3D;[{key:value}]"></a>配置方式：dubbo.provider.parameters&#x3D;[{key:value}]</h5><p>org.apache.dubbo.config.bootstrap.DubboBootstrap#startConfigCenter在此处，会触发所有configBean的刷新动作，从环境变量中获取k-v<br><img src="/img/dubbo/jvm%E9%85%8D%E7%BD%AEdubbo.param.png"></p><p>但是获取的前缀固定为dubbo.provider.parameters</p><p>所以正确的配置方式是：dubbo.provider.parameters&#x3D;[{key:value}]</p><p>其中[key:value]会在下面这个方法里被解析成map</p><p>必须匹配的value正则表达式是</p><p>“^\[((\s<em>\{\s</em>[\w_\-\.]+\s*:\s*.+?\s<em>\}\s</em>,?\s*)+)\s*\]$”<br>org.apache.dubbo.common.utils.StringUtils#parseParameters</p><p><img src="/img/dubbo/dubbo%E5%8C%B9%E9%85%8Djvm%E5%8F%82%E6%95%B0%E6%AD%A3%E5%88%99.png"></p>]]></content>
    
    
    <categories>
      
      <category>dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo注解的参数解析</title>
    <link href="/2023/03/07/dubbo/dubbo%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/03/07/dubbo/dubbo%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="配置实例："><a href="#配置实例：" class="headerlink" title="配置实例："></a>配置实例：</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@DubboService(version=<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;dubbo.provider.version&#125;</span>&quot;</span>)</span><br></code></pre></td></tr></table></figure><h1 id="源码速析"><a href="#源码速析" class="headerlink" title="源码速析"></a>源码速析</h1><h3 id="Reference准备完成后的自动注入"><a href="#Reference准备完成后的自动注入" class="headerlink" title="Reference准备完成后的自动注入"></a>Reference准备完成后的自动注入</h3><p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)</p><p>–&gt;</p><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</p><p>—-&gt;</p><p><strong>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</strong></p><p><strong>—–&gt;此处是元数据准备，占位符解析就在此处，详情见下一节</strong></p><p>——&gt;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean</p><p>bean后置处理器，此处会将bean进行自动注入，DubboReference注解在此处注入</p><p>——–&gt;</p><p>com.alibaba.spring.beans.factory.annotation.AbstractAnnotationBeanPostProcessor#postProcessPropertyValues</p><p><img src="/img/dubbo/dubbo%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%901.png"></p><p>———-&gt;org.springframework.beans.factory.annotation.InjectionMetadata#inject</p><p>————&gt;</p><p>com.alibaba.spring.beans.factory.annotation.AbstractAnnotationBeanPostProcessor.AnnotatedFieldElement#inject</p><p>————–&gt;</p><p>com.alibaba.spring.beans.factory.annotation.AbstractAnnotationBeanPostProcessor#getInjectedObject</p><p>—————-&gt;</p><p>org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor#doGetInjectedBean</p><p>到达dubbo的Reference注解处理器</p><h3 id="Reference的相关元数据准备"><a href="#Reference的相关元数据准备" class="headerlink" title="Reference的相关元数据准备"></a>Reference的相关元数据准备</h3><p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)</p><p>–&gt;</p><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</p><p>—-&gt;</p><p><strong>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</strong></p><p>——&gt;</p><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyMergedBeanDefinitionPostProcessors</p><p>——–&gt;</p><p>com.alibaba.spring.beans.factory.annotation.AbstractAnnotationBeanPostProcessor#postProcessMergedBeanDefinition</p><p>———-&gt;</p><p>com.alibaba.spring.beans.factory.annotation.AbstractAnnotationBeanPostProcessor#findInjectionMetadata</p><p>————&gt;</p><p>com.alibaba.spring.beans.factory.annotation.AbstractAnnotationBeanPostProcessor#buildAnnotatedMetadata</p><p>————–&gt;</p><p>com.alibaba.spring.beans.factory.annotation.AbstractAnnotationBeanPostProcessor#findFieldAnnotationMetadata</p><p>————–&gt;org.springframework.util.ReflectionUtils#doWithFields(java.lang.Class&lt;?&gt;, org.springframework.util.ReflectionUtils.FieldCallback, org.springframework.util.ReflectionUtils.FieldFilter)</p><p>—————-&gt;org.springframework.util.ReflectionUtils.FieldCallback#doWith</p><p><img src="/img/dubbo/dubbo%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%902.png"></p><h4 id="元数据的获取"><a href="#元数据的获取" class="headerlink" title="元数据的获取"></a>元数据的获取</h4><p>com.alibaba.spring.util.AnnotationUtils#getAnnotationAttributes(java.lang.reflect.AnnotatedElement, java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;, org.springframework.core.env.PropertyResolver, boolean, boolean, java.lang.String…)</p><p>–&gt;com.alibaba.spring.util.AnnotationUtils#tryGetMergedAnnotationAttributes</p><p>此处通过反射获取到了注解上的原始配置</p><p><img src="/img/dubbo/dubbo%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%903.png"></p><p>—-&gt;com.alibaba.spring.util.AnnotationUtils#getAnnotationAttributes(java.lang.annotation.Annotation, org.springframework.core.env.PropertyResolver, boolean, java.lang.String…)</p><p>——&gt;com.alibaba.spring.util.AnnotationUtils#getAttributes(java.lang.annotation.Annotation, org.springframework.core.env.PropertyResolver, boolean, java.lang.String…)</p><p>这一步是把没有进行用户配置的元数据剔除</p><p>——–&gt;com.alibaba.spring.util.AnnotationUtils#getAttributes(java.util.Map&lt;java.lang.String,java.lang.Object&gt;, org.springframework.core.env.PropertyResolver, java.lang.String…)</p><p>这一步把剩下的配置进行获取，主要是进行<strong>占位符解析</strong></p><p><strong>-</strong>——-→com.alibaba.spring.util.AnnotationUtils#resolvePlaceholders</p><p>———-→org.springframework.core.env.AbstractEnvironment#resolvePlaceholders</p><p>————→org.springframework.core.env.AbstractPropertyResolver#resolvePlaceholders</p><p>————–→org.springframework.core.env.AbstractPropertyResolver#doResolvePlaceholders</p><p>—————-→org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(java.lang.String, org.springframework.util.PropertyPlaceholderHelper.PlaceholderResolver)</p><p>——————→org.springframework.core.env.PropertySourcesPropertyResolver#getPropertyAsRawString</p><p><img src="/img/dubbo/dubbo%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%904.png"></p><p><img src="/img/dubbo/dubbo%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%905.png"></p><p><strong>即从spring的environment中拿取变量</strong></p>]]></content>
    
    
    <categories>
      
      <category>dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开启java.security.manager后出现AccessControlException异常</title>
    <link href="/2023/03/01/dubbo/%E5%BC%80%E5%90%AFjava-security-manager%E5%90%8E%E5%87%BA%E7%8E%B0AccessControlException%E5%BC%82%E5%B8%B8/"/>
    <url>/2023/03/01/dubbo/%E5%BC%80%E5%90%AFjava-security-manager%E5%90%8E%E5%87%BA%E7%8E%B0AccessControlException%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="0-相关问题"><a href="#0-相关问题" class="headerlink" title="0.相关问题"></a>0.相关问题</h1><p>在使用dubbo时，出现以下异常</p><p>cause: org.apache.dubbo.remoting.RemotingException: java.security.AccessControlException: access denied (“java.util.PropertyPermission” “serialization.security.check” “read”)</p><p>java.security.AccessControlException: access denied (“java.util.PropertyPermission” “dubbo.cache.router” “read”)</p><h4 id="快速解决："><a href="#快速解决：" class="headerlink" title="快速解决："></a>快速解决：</h4><p>使用AccessController.doPrivilege包裹dubbo调用</p><h6 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h6><p>原代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> helloService.sayHello(Thread.currentThread().getName());<br></code></pre></td></tr></table></figure><p>修改后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> helloService.sayHello(Thread.currentThread().getName());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="1-原因"><a href="#1-原因" class="headerlink" title="1.原因"></a>1.原因</h1><p>当开启了安全管理器时，常用方式为添加JVM参数-Djava.security.manager，在进行部分操作时，会检查当前保护域是否有该权限。</p><p>比较常见的是使用了某些公共线程池，比如：</p><h6 id="ForkJoinPool-commonPool-submit-forkJoinAction"><a href="#ForkJoinPool-commonPool-submit-forkJoinAction" class="headerlink" title="ForkJoinPool.commonPool().submit(forkJoinAction);"></a>ForkJoinPool.commonPool().submit(forkJoinAction);</h6><p>类的描述为：（直接查看源码可见）</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">An ExecutorService <span class="hljs-keyword">for</span> running ForkJoinTasks. A ForkJoinPool provides the entry point <span class="hljs-keyword">for</span> submissions <span class="hljs-keyword">from</span> non-ForkJoinTask clients, <span class="hljs-keyword">as</span> well <span class="hljs-keyword">as</span> management <span class="hljs-built_in">and</span> monitoring operations.<br>A ForkJoinPool differs <span class="hljs-keyword">from</span> other kinds <span class="hljs-keyword">of</span> ExecutorService mainly <span class="hljs-keyword">by</span> virtue <span class="hljs-keyword">of</span> employing work-stealing: all threads <span class="hljs-keyword">in</span> the pool attempt <span class="hljs-keyword">to</span> find <span class="hljs-built_in">and</span> execute tasks submitted <span class="hljs-keyword">to</span> the pool <span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span> created <span class="hljs-keyword">by</span> other active tasks (eventually blocking waiting <span class="hljs-keyword">for</span> work <span class="hljs-keyword">if</span> none exist). This enables efficient processing <span class="hljs-keyword">when</span> most tasks spawn other subtasks (<span class="hljs-keyword">as</span> <span class="hljs-keyword">do</span> most ForkJoinTasks), <span class="hljs-keyword">as</span> well <span class="hljs-keyword">as</span> <span class="hljs-keyword">when</span> many small tasks are submitted <span class="hljs-keyword">to</span> the pool <span class="hljs-keyword">from</span> external clients. Especially <span class="hljs-keyword">when</span> setting asyncMode <span class="hljs-keyword">to</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">in</span> constructors, ForkJoinPools may also be appropriate <span class="hljs-keyword">for</span> use <span class="hljs-keyword">with</span> <span class="hljs-keyword">event</span>-style tasks that are never joined.<br>A <span class="hljs-keyword">static</span> commonPool() <span class="hljs-built_in">is</span> available <span class="hljs-built_in">and</span> appropriate <span class="hljs-keyword">for</span> most applications. The common pool <span class="hljs-built_in">is</span> used <span class="hljs-keyword">by</span> any ForkJoinTask that <span class="hljs-built_in">is</span> <span class="hljs-built_in">not</span> explicitly submitted <span class="hljs-keyword">to</span> a specified pool. <span class="hljs-keyword">Using</span> the common pool normally reduces resource usage (its threads are slowly reclaimed during periods <span class="hljs-keyword">of</span> non-use, <span class="hljs-built_in">and</span> reinstated upon subsequent use).<br><span class="hljs-keyword">For</span> applications that require separate <span class="hljs-built_in">or</span> <span class="hljs-keyword">custom</span> pools, a ForkJoinPool may be constructed <span class="hljs-keyword">with</span> a given target parallelism level; <span class="hljs-keyword">by</span> <span class="hljs-keyword">default</span>, equal <span class="hljs-keyword">to</span> the number <span class="hljs-keyword">of</span> available processors. The pool attempts <span class="hljs-keyword">to</span> maintain enough active (<span class="hljs-built_in">or</span> available) threads <span class="hljs-keyword">by</span> dynamically adding, suspending, <span class="hljs-built_in">or</span> resuming internal worker threads, even <span class="hljs-keyword">if</span> some tasks are stalled waiting <span class="hljs-keyword">to</span> <span class="hljs-keyword">join</span> others. However, no such adjustments are guaranteed <span class="hljs-keyword">in</span> the face <span class="hljs-keyword">of</span> blocked I/O <span class="hljs-built_in">or</span> other unmanaged synchronization. The nested ForkJoinPool.ManagedBlocker <span class="hljs-keyword">interface</span> enables extension <span class="hljs-keyword">of</span> the kinds <span class="hljs-keyword">of</span> synchronization accommodated.<br><span class="hljs-keyword">In</span> addition <span class="hljs-keyword">to</span> execution <span class="hljs-built_in">and</span> lifecycle control methods, this <span class="hljs-keyword">class</span> provides status check methods (<span class="hljs-keyword">for</span> example getStealCount) that are intended <span class="hljs-keyword">to</span> aid <span class="hljs-keyword">in</span> developing, tuning, <span class="hljs-built_in">and</span> monitoring fork/<span class="hljs-keyword">join</span> applications. Also, method toString returns indications <span class="hljs-keyword">of</span> pool state <span class="hljs-keyword">in</span> a convenient form <span class="hljs-keyword">for</span> informal monitoring.<br><span class="hljs-keyword">As</span> <span class="hljs-built_in">is</span> the <span class="hljs-keyword">case</span> <span class="hljs-keyword">with</span> other ExecutorServices, there are three main task execution methods summarized <span class="hljs-keyword">in</span> the following table. These are designed <span class="hljs-keyword">to</span> be used primarily <span class="hljs-keyword">by</span> clients <span class="hljs-built_in">not</span> already engaged <span class="hljs-keyword">in</span> fork/<span class="hljs-keyword">join</span> computations <span class="hljs-keyword">in</span> the current pool. The main forms <span class="hljs-keyword">of</span> these methods accept instances <span class="hljs-keyword">of</span> ForkJoinTask, but overloaded forms also allow mixed execution <span class="hljs-keyword">of</span> plain Runnable- <span class="hljs-built_in">or</span> Callable- based activities <span class="hljs-keyword">as</span> well. However, tasks that are already executing <span class="hljs-keyword">in</span> a pool should normally instead use the within-computation forms listed <span class="hljs-keyword">in</span> the table unless <span class="hljs-keyword">using</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">event</span>-style tasks that are <span class="hljs-built_in">not</span> usually joined, <span class="hljs-keyword">in</span> which <span class="hljs-keyword">case</span> there <span class="hljs-built_in">is</span> little difference among choice <span class="hljs-keyword">of</span> methods.<br>Summary <span class="hljs-keyword">of</span> task execution methods<br><br><span class="hljs-keyword">Call</span> <span class="hljs-keyword">from</span> non-fork/<span class="hljs-keyword">join</span> clients<br><span class="hljs-keyword">Call</span> <span class="hljs-keyword">from</span> within fork/<span class="hljs-keyword">join</span> computations<br>Arrange <span class="hljs-keyword">async</span> execution<br>execute(ForkJoinTask)<br>ForkJoinTask.fork<br><span class="hljs-built_in">Await</span> <span class="hljs-built_in">and</span> obtain result<br>invoke(ForkJoinTask)<br>ForkJoinTask.invoke<br>Arrange exec <span class="hljs-built_in">and</span> obtain Future<br>submit(ForkJoinTask)<br>ForkJoinTask.fork (ForkJoinTasks are Futures)<br>The common pool <span class="hljs-built_in">is</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">default</span> constructed <span class="hljs-keyword">with</span> <span class="hljs-keyword">default</span> parameters, but these may be controlled <span class="hljs-keyword">by</span> setting three system properties:<br>java.util.concurrent.ForkJoinPool.common.parallelism - the parallelism level, a non-negative <span class="hljs-type">integer</span><br>java.util.concurrent.ForkJoinPool.common.threadFactory - the <span class="hljs-keyword">class</span> name <span class="hljs-keyword">of</span> a ForkJoinPool.ForkJoinWorkerThreadFactory<br>java.util.concurrent.ForkJoinPool.common.exceptionHandler - the <span class="hljs-keyword">class</span> name <span class="hljs-keyword">of</span> a Thread.UncaughtExceptionHandler<br><span class="hljs-keyword">If</span> a SecurityManager <span class="hljs-built_in">is</span> present <span class="hljs-built_in">and</span> no factory <span class="hljs-built_in">is</span> specified, <span class="hljs-keyword">then</span> the <span class="hljs-keyword">default</span> pool uses a factory supplying threads that have no Permissions enabled. The system <span class="hljs-keyword">class</span> loader <span class="hljs-built_in">is</span> used <span class="hljs-keyword">to</span> load these classes. Upon any <span class="hljs-keyword">error</span> <span class="hljs-keyword">in</span> establishing these settings, <span class="hljs-keyword">default</span> parameters are used. It <span class="hljs-built_in">is</span> possible <span class="hljs-keyword">to</span> disable <span class="hljs-built_in">or</span> limit the use <span class="hljs-keyword">of</span> threads <span class="hljs-keyword">in</span> the common pool <span class="hljs-keyword">by</span> setting the parallelism <span class="hljs-keyword">property</span> <span class="hljs-keyword">to</span> zero, <span class="hljs-built_in">and</span>/<span class="hljs-built_in">or</span> <span class="hljs-keyword">using</span> a factory that may <span class="hljs-keyword">return</span> null. However doing so may cause unjoined tasks <span class="hljs-keyword">to</span> never be executed.<br>Implementation notes: This implementation restricts the maximum number <span class="hljs-keyword">of</span> running threads <span class="hljs-keyword">to</span> <span class="hljs-number">32767</span>. Attempts <span class="hljs-keyword">to</span> create pools <span class="hljs-keyword">with</span> greater than the maximum number result <span class="hljs-keyword">in</span> IllegalArgumentException.<br>This implementation rejects submitted tasks (that <span class="hljs-built_in">is</span>, <span class="hljs-keyword">by</span> throwing RejectedExecutionException) only <span class="hljs-keyword">when</span> the pool <span class="hljs-built_in">is</span> shut down <span class="hljs-built_in">or</span> internal resources have been exhausted.<br><span class="hljs-symbol">Since:</span><br><span class="hljs-number">1.7</span><br><span class="hljs-symbol">Author:</span><br>Doug Lea<br></code></pre></td></tr></table></figure><p>注意此句：</p><p>If a SecurityManager is present and no factory is specified, then the default pool uses a factory supplying threads that have no Permissions enabled.</p><p>如果存在SecurityManager且没有指定工厂，则默认池使用工厂提供没有启用权限的线程。</p><p><strong>所以默认情况下，commonPool是没有任何权限的线程池，将任务提交到该线程池，就会出现权限检查不通过的错误。</strong></p><p><strong>解决方式即使用Java提供的方法，使用原调用方权限</strong></p><p>AccessController.doPrivilege的相关内容为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs the specified &#123;<span class="hljs-doctag">@code</span> PrivilegedAction&#125; with privileges</span><br><span class="hljs-comment"> * enabled. The action is performed with &lt;i&gt;all&lt;/i&gt; of the permissions</span><br><span class="hljs-comment"> * possessed by the caller&#x27;s protection domain.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If the action&#x27;s &#123;<span class="hljs-doctag">@code</span> run&#125; method throws an (unchecked)</span><br><span class="hljs-comment"> * exception, it will propagate through this method.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; Note that any DomainCombiner associated with the current</span><br><span class="hljs-comment"> * AccessControlContext will be ignored while the action is performed.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; the type of the value returned by the PrivilegedAction&#x27;s</span><br><span class="hljs-comment"> *                  &#123;<span class="hljs-doctag">@code</span> run&#125; method.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> action the action to be performed.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the value returned by the action&#x27;s &#123;<span class="hljs-doctag">@code</span> run&#125; method.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@exception</span> NullPointerException if the action is &#123;<span class="hljs-doctag">@code</span> null&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #doPrivileged(PrivilegedAction,AccessControlContext)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #doPrivileged(PrivilegedExceptionAction)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #doPrivilegedWithCombiner(PrivilegedAction)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> java.security.DomainCombiner</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@CallerSensitive</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> &lt;T&gt; T <span class="hljs-title function_">doPrivileged</span><span class="hljs-params">(PrivilegedAction&lt;T&gt; action)</span>;<br></code></pre></td></tr></table></figure><p>注意这句话：Performs the specified with privileges enabled. The action is performed with of the permissions possessed by the caller’s protection domain.</p><p><strong>以启用特权的方式执行指定的。该操作是使用调用方保护域所拥有的权限执行的。</strong></p><p><strong>为了理解doPrivilege的行为，进行以下测试：</strong></p><p>NoPermissionTools为无任何权限的类</p><p>1.无权限验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">appName</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;app.name&quot;</span>);<br>                    System.out.println(appName);<br>                &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                    System.out.println(e.getMessage());<br>                &#125;<br>            &#125;<br>        &#125;;<br>        NoPermissionTools.submit(thread1);<br><br>结果为：<br>access <span class="hljs-title function_">denied</span> <span class="hljs-params">(<span class="hljs-string">&quot;java.util.PropertyPermission&quot;</span> <span class="hljs-string">&quot;app.name&quot;</span> <span class="hljs-string">&quot;read&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>2.包裹doPrivileged</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Runnable</span> thread2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-title class_">String</span> appName = <span class="hljs-title class_">AccessController</span>.<span class="hljs-title function_">doPrivileged</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;<span class="hljs-title class_">String</span>&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                            <span class="hljs-title class_">String</span> appName = <span class="hljs-title class_">System</span>.<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">&quot;app.name&quot;</span>);<br>                            <span class="hljs-keyword">return</span> appName;<br>                        &#125;<br>                    &#125;);<br>                    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;use doPrivileged: &quot;</span> + appName);<br>                &#125;<span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e)&#123;<br>                    <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;use doPrivileged: &quot;</span> + e.<span class="hljs-title function_">getMessage</span>());<br>                &#125;<br><br>            &#125;<br>        &#125;;<br>        <span class="hljs-title class_">NoPermissionTools</span>.<span class="hljs-title function_">submit</span>(thread2);<br><br>结果为：<br>use <span class="hljs-attr">doPrivileged</span>: <span class="hljs-title class_">SecurityTest</span><br></code></pre></td></tr></table></figure><p>3.测试doPrivileged的传递性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">String</span> appName = <span class="hljs-title class_">AccessController</span>.<span class="hljs-title function_">doPrivileged</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;<span class="hljs-title class_">String</span>&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title class_">String</span> appName = <span class="hljs-title class_">NoPermissionTools</span>.<span class="hljs-title function_">getAppName</span>();<br>                <span class="hljs-keyword">return</span> appName;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(appName);<br><br><br><br>org.<span class="hljs-property">example</span>.<span class="hljs-property">NoPermissionTools</span>#getAppName<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAppName</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">System</span>.<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">&quot;app.name&quot;</span>);<br>    &#125;<br><br>结果：<span class="hljs-title class_">Exception</span> <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.<span class="hljs-property">security</span>.<span class="hljs-property">AccessControlException</span>: access denied (<span class="hljs-string">&quot;java.util.PropertyPermission&quot;</span> <span class="hljs-string">&quot;app.name&quot;</span> <span class="hljs-string">&quot;read&quot;</span>)<br></code></pre></td></tr></table></figure><p>4测试基于谁的权限</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript">org.<span class="hljs-property">example</span>.<span class="hljs-property">NoPermissionTools</span>#getAppName<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getAppName</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">String</span> appName = <span class="hljs-title class_">AccessController</span>.<span class="hljs-title function_">doPrivileged</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;<span class="hljs-title class_">String</span>&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title class_">String</span> appName = <span class="hljs-title class_">System</span>.<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">&quot;app.name&quot;</span>);<br>                <span class="hljs-keyword">return</span> appName;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> appName;<br>    &#125;<br><br>结果：<br><span class="hljs-title class_">Exception</span> <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.<span class="hljs-property">security</span>.<span class="hljs-property">AccessControlException</span>: access denied (<span class="hljs-string">&quot;java.util.PropertyPermission&quot;</span> <span class="hljs-string">&quot;app.name&quot;</span> <span class="hljs-string">&quot;read&quot;</span>)<br></code></pre></td></tr></table></figure><p>5.理论上consumer接口也应该同理，验证：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">System</span>.setProperty(&quot;app.name&quot;,&quot;SecurityTest&quot;);<br>        NoPermissionTools.run(<span class="hljs-built_in">new</span> Consumer() &#123;<br>            @Override<br>            <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> accept(<span class="hljs-keyword">Object</span> o) &#123;<br>                String property = <span class="hljs-keyword">System</span>.getProperty(&quot;app.name&quot;);<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(property);<br>            &#125;<br>        &#125;);<br><br><br>org.example.NoPermissionTools#run<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> run(Consumer consumer)&#123;<br>        consumer.accept(&quot;1&quot;);<br>    &#125;<br><br>结果：<br><span class="hljs-keyword">Exception</span> <span class="hljs-keyword">in</span> thread &quot;main&quot; java.<span class="hljs-keyword">security</span>.AccessControlException: <span class="hljs-keyword">access</span> denied (&quot;java.util.PropertyPermission&quot; &quot;app.name&quot; &quot;read&quot;)<br></code></pre></td></tr></table></figure><p>6.当都没有权限时</p><p>将权限配置取消，结果：</p><p>use doPrivileged: access denied (“java.util.PropertyPermission” “<a href="http://app.name/">app.name</a>“ “read”)</p><p>基于测试结果可知：</p><p>一、使用<strong>调用方权限，</strong>如A→B → doPrivileged，指的是调用doPrivileged代码所在class的权限，即B，而不是A。（通过4）</p><p>二、权限无法传递，如A→ doPrivileged → B，B中进行的需要权限的操作依旧无法使用A的权限。（通过3）</p><p>三、该方法只能实现将在A中进行的操作交给B执行时，B中无权限使用A的权限。而无法实现执行A、B都无权限的操作。（通过6）</p><p>所以该方法是无法越过安全检查的，究根到底，进行高权限操作代码必须在拥有权限的Class里。只是在某些情况下需要将这部分代码交给别的模块执行，在别的模块没有权限的情况下，可以使用doPrivileged获得权限。</p>]]></content>
    
    
    <categories>
      
      <category>dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo在Springboot下服务方和消费方的信息注册时机</title>
    <link href="/2023/02/27/dubbo/Dubbo%E5%9C%A8Springboot%E4%B8%8B%E6%9C%8D%E5%8A%A1%E6%96%B9%E5%92%8C%E6%B6%88%E8%B4%B9%E6%96%B9%E7%9A%84%E4%BF%A1%E6%81%AF%E6%B3%A8%E5%86%8C%E6%97%B6%E6%9C%BA/"/>
    <url>/2023/02/27/dubbo/Dubbo%E5%9C%A8Springboot%E4%B8%8B%E6%9C%8D%E5%8A%A1%E6%96%B9%E5%92%8C%E6%B6%88%E8%B4%B9%E6%96%B9%E7%9A%84%E4%BF%A1%E6%81%AF%E6%B3%A8%E5%86%8C%E6%97%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-QA"><a href="#1-QA" class="headerlink" title="1.QA"></a>1.QA</h1><h5 id="关于原理-必须保证什么条件，服务方才会进行暴露？"><a href="#关于原理-必须保证什么条件，服务方才会进行暴露？" class="headerlink" title="关于原理.必须保证什么条件，服务方才会进行暴露？"></a>关于原理.必须保证什么条件，服务方才会进行暴露？</h5><p>以下两点必须全部满足</p><p>1.注入Spring中的bean为ServiceBean。</p><p>2.服务暴露入口类注入到了spring中。</p><h5 id="关于原理-必须保证什么条件，消费方才会进行暴露？"><a href="#关于原理-必须保证什么条件，消费方才会进行暴露？" class="headerlink" title="关于原理.必须保证什么条件，消费方才会进行暴露？"></a>关于原理.必须保证什么条件，消费方才会进行暴露？</h5><p>满足一下两点其一即可</p><p>1.作为ReferenceBean注入，且显示开启饿汉模式，即reference的配置init为true（通过consumer配置无效）。</p><p>2.作为ReferenceBean注入，在任意bean中作为依赖进行了依赖注入。</p><h5 id="关于一-为什要调整自动装配-x2F-添加注解？"><a href="#关于一-为什要调整自动装配-x2F-添加注解？" class="headerlink" title="关于一.为什要调整自动装配&#x2F;添加注解？"></a>关于一.为什要调整自动装配&#x2F;添加注解？</h5><p>因为发现有业务的自动装配是自己实现的，而升级dubbo后，原本部分入口类类注入的逻辑进行了修改，整合到了autoconfigure中，导致没引入新autoconfigure模块会不注入相关类。</p><p>至于添加@EnableDubbo注解其实就是手动进行入口类的注入。</p><h5 id="关于二-为什么使用-DubboService的方式，要配置扫描路径？"><a href="#关于二-为什么使用-DubboService的方式，要配置扫描路径？" class="headerlink" title="关于二.为什么使用@DubboService的方式，要配置扫描路径？"></a>关于二.为什么使用@DubboService的方式，要配置扫描路径？</h5><p>DubboService注解其实只是个标注，通过包扫描路径的配置，才会去扫描这些被标注的类，然后将这些类的bean包装成ServiceBean。</p><h5 id="关于二-为什么使用-DubboService的方式，配置了扫描路径还不行？"><a href="#关于二-为什么使用-DubboService的方式，配置了扫描路径还不行？" class="headerlink" title="关于二.为什么使用@DubboService的方式，配置了扫描路径还不行？"></a>关于二.为什么使用@DubboService的方式，配置了扫描路径还不行？</h5><p>其实也有前提是自动装配依赖正确，否则配置文件添加dubbo.scan.base-packages可能不生效，因为读取相关配置功能在autoconfigure中开启。</p><p>dubbo.scan.base-packages或@DubboComponentScan配置后，DubboComponentScan的处理类里也会进行开启服务暴露相关类的注入（如果依赖正确，autoconfigure里就会进行注入）。</p><h1 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2.源码解析"></a>2.源码解析</h1><h5 id="一、服务暴露"><a href="#一、服务暴露" class="headerlink" title="一、服务暴露"></a>一、服务暴露</h5><p>ServiceBean如何与普通Bean区分开？<br>ServiceBean的继承关系</p><p><img src="/img/dubbo/ServiceBean%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png"></p><p>在抽象父类AbstractConfig中，有一个PostConstruct方法，会将自身加到一个静态变量中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addIntoConfigManager</span><span class="hljs-params">()</span> &#123;<br>ApplicationModel.getConfigManager().addConfig(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个静态变量所在类为：org.apache.dubbo.config.context.ConfigManager</p><p>这个类管理了Dubbo框架内所有的配置信息，包括provider、cosnumer、service、reference、protocol等</p><p>那么ConfigManager中的Service配置被谁获取使用呢？<br>在Dubbo的启动类DubboBootstrap中</p><p>org.apache.dubbo.config.bootstrap.DubboBootstrap#start</p><p>—org.apache.dubbo.config.bootstrap.DubboBootstrap#exportServices</p><p>会从ConfigManager的中获取所有的Services进行暴露</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exportServices</span><span class="hljs-params">()</span> &#123;<br>configManager.getServices().forEach(sc -&gt; &#123;...&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后问题就来到了Bootstarp的start方法在什么时候触发？<br>在一个监听器中</p><p>org.apache.dubbo.config.spring.context.DubboBootstrapApplicationListener</p><p>在监听到对应事件后，会执行start方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onContextRefreshedEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>dubboBootstrap.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>综上所述，在Springboot场景下，服务如果想暴露，必须将自己作为ServiceBean注入且DubboBootstrapApplicationListener注册进spring。<br>ServiceBean可以自己手动包装、注入，也可以借助于@DubboService、@DubboComponentScan</p><p>DubboBootstrapApplicationListener的注册入口有很多，许多Dubbo的入口注解、自动装配类都会进行注册。</p><p>二、为什么消费方可以注册上来？<br>同样的思路，从org.apache.dubbo.config.spring.ReferenceBean开始看</p><p><img src="/img/dubbo/ReferenceBean%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png"></p><p>ReferenceBean同样实现了AbstractConfig，会把自己添加到配置管理器中，但他并不依赖于Bootstrap读取配置暴露。详见下文。</p><p>ReferenceBean实现了InitializingBean</p><p>默认在这里是不会加载的，默认是懒加载，但是如果显示制定了init，那么在此处就会执行服务引入，将消费者注册上去</p><p>org.apache.dubbo.config.spring.ReferenceBean#afterPropertiesSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//先把一些配置准备好</span><br><span class="hljs-comment">// Initializes Dubbo&#x27;s Config Beans before @Reference bean autowiring</span><br>prepareDubboConfigBeans();<br><span class="hljs-comment">//默认懒加载</span><br><span class="hljs-comment">// lazy init by default.</span><br><span class="hljs-keyword">if</span> (init == <span class="hljs-literal">null</span>) &#123;<br>init = <span class="hljs-literal">false</span>;<br>&#125;<br><br>   <span class="hljs-comment">// eager init if necessary.</span><br>   <span class="hljs-keyword">if</span> (shouldInit()) &#123;<br>    <span class="hljs-comment">//饿汉模式直接调用初始化方法</span><br>        getObject();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>tips:这里的逻辑其实只有reference显示制定了init才会生效，即通过consumer配置init无效。</p><p>if (init &#x3D;&#x3D; null) { init &#x3D; false; }这里会在init为null时默认置为false，而在shouldInit()中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处取init的值</span><br><span class="hljs-type">Boolean</span> <span class="hljs-variable">shouldInit</span> <span class="hljs-operator">=</span> isInit();<br><span class="hljs-comment">//为null且consumer不为空时采用consumer的init属性</span><br><span class="hljs-keyword">if</span> (shouldInit == <span class="hljs-literal">null</span> &amp;&amp; getConsumer() != <span class="hljs-literal">null</span>) &#123;<br>shouldInit = getConsumer().isInit();<br>&#125;<br></code></pre></td></tr></table></figure><p>而从之前的代码可知，如果为null，必定会被置为false，所以这里根本走不到<br>那么默认是懒加载，为什么启动时，什么都没做就注册上去了？</p><p>那肯定是因为使用了相关的依赖注入，无论是什么方式在别的bean中注入了ReferenceBean，都会执行org.springframework.beans.factory.FactoryBean#getObject方法，就是上面提到的饿汉模式直接调用的方法</p><p>而在ReferenceBean中的实现方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.get();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.destroyed) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;The invoker of ReferenceConfig(&quot;</span> + <span class="hljs-built_in">this</span>.url + <span class="hljs-string">&quot;) has already destroyed!&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.ref == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.init();<br>&#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.ref;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>org.apache.dubbo.config.ReferenceConfig#init 进行一些配置的加载，提供给后续拼接成消费方url，即consumer:&#x2F;&#x2F;…</p><p>—org.apache.dubbo.config.ReferenceConfig#createProxy</p><p>—REF_PROTOCOL.refer 在此处进行消费方的注册</p><p>那么如果只注入了bean，没有在任何地方以任何形式引入，消费者还会注册吗？<br>答案是不会。</p><p>在DubboBootstrap中，处理ConfigManager中的reference配置的方法</p><p>可以看到，这里依旧判断是懒加载的话，不会执行初始化</p><p>而我们上面知道，如果是饿汉模式的，在bean初始化的时候实现InitializingBean，就会初始化了。所以其实bootstrap里的这个方法，在本文这场景都没有进行注册消费方的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">referServices</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.cache == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.cache = ReferenceConfigCache.getCache();<br>&#125;<br><br><span class="hljs-built_in">this</span>.configManager.getReferences().forEach((rc) -&gt; &#123;<br>    <span class="hljs-type">ReferenceConfig</span> <span class="hljs-variable">referenceConfig</span> <span class="hljs-operator">=</span> (ReferenceConfig)rc;<br>    referenceConfig.setBootstrap(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">if</span> (rc.shouldInit()) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.referAsync) &#123;<br>            CompletableFuture&lt;Object&gt; future = ScheduledCompletableFuture.submit(<span class="hljs-built_in">this</span>.executorRepository.getServiceExporterExecutor(), () -&gt; &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.cache.get(rc);<br>            &#125;);<br>            <span class="hljs-built_in">this</span>.asyncReferringFutures.add(future);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.cache.get(rc);<br>        &#125;<br>    &#125;<br><br>&#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo如何指定注册的ip</title>
    <link href="/2023/02/21/dubbo/dubbo%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E6%B3%A8%E5%86%8C%E7%9A%84ip/"/>
    <url>/2023/02/21/dubbo/dubbo%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E6%B3%A8%E5%86%8C%E7%9A%84ip/</url>
    
    <content type="html"><![CDATA[<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h1><p>出现注册上去的ip与实际ip不一致，或者本地有多个网卡，注册了错误的网卡ip</p><h1 id="2-解决方案–手动指定ip"><a href="#2-解决方案–手动指定ip" class="headerlink" title="2.解决方案–手动指定ip"></a>2.解决方案–手动指定ip</h1><h3 id="1-适用提供方"><a href="#1-适用提供方" class="headerlink" title="1.适用提供方"></a>1.适用提供方</h3><p>按优先级：</p><h4 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h4><p>通过配置以下值进行ip指定，可以配置在jvm参数中，也可以配置到系统环境变量中。系统环境变量优先级高于jvm参数。</p><ul><li><strong>DUBBO_IP_TO_REGISTRY</strong>：注册到注册中心的 ip 地址</li><li><strong>DUBBO_PORT_TO_REGISTRY</strong>：注册到注册中心的 port 端口</li><li><strong>DUBBO_IP_TO_BIND</strong>：监听 ip 地址</li><li><strong>DUBBO_PORT_TO_BIND</strong>：监听 port 端口</li></ul><p>也可单独指定某个协议绑定的ip，格式如下：</p><ul><li><strong>HESSIAN_DUBBO_PORT_TO_BIND</strong>：hessian 协议绑定的 port</li><li><strong>DUBBO_DUBBO_PORT_TO_BIND</strong>：dubbo 协议绑定的 port</li><li><strong>HESSIAN_DUBBO_IP_TO_REGISTRY</strong>：hessian 协议注册的 ip</li><li><strong>DUBBO_DUBBO_IP_TO_REGISTRY</strong>：dubbo 协议注册的 ip</li><li>·······</li></ul><p>某个协议指定的ip优先级高于第一种所有协议都生效的配置。</p><h4 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h4><p>protocol配置，比如：dubbo.protocol.host&#x3D;x.x.x.x</p><h4 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h4><p>provider配置，比如：dubbo.provider.host&#x3D;x.x.x.x</p><h3 id="2-适用消费方"><a href="#2-适用消费方" class="headerlink" title="2.适用消费方"></a>2.适用消费方</h3><p>同第1点，但只有一个key可配置</p><ul><li><strong>DUBBO_IP_TO_REGISTRY</strong>：注册到注册中心的 ip 地址</li></ul><h1 id="3-Dubbo源码梳理"><a href="#3-Dubbo源码梳理" class="headerlink" title="3.Dubbo源码梳理"></a>3.Dubbo源码梳理</h1><p>以提供方为例：（消费方很简单，就是获取<strong>DUBBO_IP_TO_REGISTRY</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// export service</span><br><span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> findConfigedHosts(protocolConfig, registryURLs, map);<br>serviceMetadata.addAttribute(<span class="hljs-string">&quot;host&quot;</span>, host);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> findConfigedPorts(protocolConfig, name, map);<br>serviceMetadata.addAttribute(<span class="hljs-string">&quot;port&quot;</span>, port);<br></code></pre></td></tr></table></figure><h4 id="以host为例"><a href="#以host为例" class="headerlink" title="以host为例"></a>以host为例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">findConfigedHosts</span><span class="hljs-params">(ProtocolConfig protocolConfig,</span><br><span class="hljs-params">                                     List&lt;URL&gt; registryURLs,</span><br><span class="hljs-params">                                     Map&lt;String, String&gt; map)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">anyhost</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br> <br>        <span class="hljs-type">String</span> <span class="hljs-variable">hostToBind</span> <span class="hljs-operator">=</span> getValueFromConfig(protocolConfig, DUBBO_IP_TO_BIND);<br>        <span class="hljs-keyword">if</span> (hostToBind != <span class="hljs-literal">null</span> &amp;&amp; hostToBind.length() &gt; <span class="hljs-number">0</span> &amp;&amp; isInvalidLocalHost(hostToBind)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Specified invalid bind ip from property:&quot;</span> + DUBBO_IP_TO_BIND + <span class="hljs-string">&quot;, value:&quot;</span> + hostToBind);<br>        &#125;<br> <br>        <span class="hljs-comment">// if bind ip is not found in environment, keep looking up</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(hostToBind)) &#123;<br>            hostToBind = protocolConfig.getHost();<br>            <span class="hljs-keyword">if</span> (provider != <span class="hljs-literal">null</span> &amp;&amp; StringUtils.isEmpty(hostToBind)) &#123;<br>                hostToBind = provider.getHost();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isInvalidLocalHost(hostToBind)) &#123;<br>                anyhost = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    logger.info(<span class="hljs-string">&quot;No valid ip found from environment, try to find valid host from DNS.&quot;</span>);<br>                    hostToBind = InetAddress.getLocalHost().getHostAddress();<br>                &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>                    logger.warn(e.getMessage(), e);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (isInvalidLocalHost(hostToBind)) &#123;<br>                    <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;<br>                        <span class="hljs-keyword">for</span> (URL registryURL : registryURLs) &#123;<br>                            <span class="hljs-keyword">if</span> (MULTICAST.equalsIgnoreCase(registryURL.getParameter(<span class="hljs-string">&quot;registry&quot;</span>))) &#123;<br>                                <span class="hljs-comment">// skip multicast registry since we cannot connect to it via Socket</span><br>                                <span class="hljs-keyword">continue</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>()) &#123;<br>                                <span class="hljs-type">SocketAddress</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(registryURL.getHost(), registryURL.getPort());<br>                                socket.connect(addr, <span class="hljs-number">1000</span>);<br>                                hostToBind = socket.getLocalAddress().getHostAddress();<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                                logger.warn(e.getMessage(), e);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (isInvalidLocalHost(hostToBind)) &#123;<br>                        hostToBind = getLocalHost();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br> <br>        map.put(BIND_IP_KEY, hostToBind);<br> <br>        <span class="hljs-comment">// registry ip is not used for bind ip by default</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hostToRegistry</span> <span class="hljs-operator">=</span> getValueFromConfig(protocolConfig, DUBBO_IP_TO_REGISTRY);<br>        <span class="hljs-keyword">if</span> (hostToRegistry != <span class="hljs-literal">null</span> &amp;&amp; hostToRegistry.length() &gt; <span class="hljs-number">0</span> &amp;&amp; isInvalidLocalHost(hostToRegistry)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Specified invalid registry ip from property:&quot;</span> + DUBBO_IP_TO_REGISTRY + <span class="hljs-string">&quot;, value:&quot;</span> + hostToRegistry);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (StringUtils.isEmpty(hostToRegistry)) &#123;<br>            <span class="hljs-comment">// bind ip is used as registry ip by default</span><br>            hostToRegistry = hostToBind;<br>        &#125;<br> <br>        map.put(ANYHOST_KEY, String.valueOf(anyhost));<br> <br>        <span class="hljs-keyword">return</span> hostToRegistry;<br>    &#125;<br> <br> <br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getValueFromConfig</span><span class="hljs-params">(ProtocolConfig protocolConfig, String key)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(protocolConfig.getName())) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">protocolPrefix</span> <span class="hljs-operator">=</span> protocolConfig.getName().toUpperCase() + <span class="hljs-string">&quot;_&quot;</span>;<br>            value = ConfigUtils.getSystemProperty(protocolPrefix + key);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(value)) &#123;<br>            value = ConfigUtils.getSystemProperty(key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br></code></pre></td></tr></table></figure><p>从上述源码可知：</p><h5 id="bind-ip"><a href="#bind-ip" class="headerlink" title="bind.ip:"></a>bind.ip:</h5><p>protocolName_DUBBO_IP_TO_BIND &gt; DUBBO_IP_TO_BIND &gt;</p><p>protocl.host &gt; provider.host&gt;InetAddress.getLocalHost().getHostAddress()&gt;用socket与注册中心通信，成功连接后，使用建立连接的本地ip</p><h5 id="registry-ip"><a href="#registry-ip" class="headerlink" title="registry.ip:"></a>registry.ip:</h5><p>protocolName_DUBBO_IP_TO_REGISTRY &gt; DUBBO_IP_TO_REGISTRY &gt; bind.ip</p>]]></content>
    
    
    <categories>
      
      <category>dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ForkJoinPool</title>
    <link href="/2023/02/20/java/ForkJoinPool/"/>
    <url>/2023/02/20/java/ForkJoinPool/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Pool启动流程→初始任务提交流程"><a href="#1-Pool启动流程→初始任务提交流程" class="headerlink" title="1.Pool启动流程→初始任务提交流程"></a>1.Pool启动流程→初始任务提交流程</h1><h3 id="queue列表为空，进行初始化"><a href="#queue列表为空，进行初始化" class="headerlink" title="queue列表为空，进行初始化"></a>queue列表为空，进行初始化</h3><p>java.util.concurrent.ForkJoinPool#externalPush</p><p>workQueues &#x3D;&#x3D; null<br>–&gt;</p><h3 id="然后初始化一个queue，放在queue列表的某个位置（计算所得，不重要）"><a href="#然后初始化一个queue，放在queue列表的某个位置（计算所得，不重要）" class="headerlink" title="然后初始化一个queue，放在queue列表的某个位置（计算所得，不重要）"></a>然后初始化一个queue，放在queue列表的某个位置（计算所得，不重要）</h3><p>java.util.concurrent.ForkJoinPool#externalSubmit</p><p>workQueues &#x3D; new WorkQueue[n];</p><p>q &#x3D; new WorkQueue(this, null);</p><p>ws[k] &#x3D; q;</p><h5 id="在启动时判断workQueue队列数组（n个队列，对应多个线程自己的工作队列）是否初始化，未初始化先初始化，在新建一个queue放进数组"><a href="#在启动时判断workQueue队列数组（n个队列，对应多个线程自己的工作队列）是否初始化，未初始化先初始化，在新建一个queue放进数组" class="headerlink" title="在启动时判断workQueue队列数组（n个队列，对应多个线程自己的工作队列）是否初始化，未初始化先初始化，在新建一个queue放进数组"></a>在启动时判断workQueue队列数组（n个队列，对应多个线程自己的工作队列）是否初始化，未初始化先初始化，在新建一个queue放进数组</h5><h3 id="然后取出这个queue中的任务数组，把当前提交的任务添加进去"><a href="#然后取出这个queue中的任务数组，把当前提交的任务添加进去" class="headerlink" title="然后取出这个queue中的任务数组，把当前提交的任务添加进去"></a>然后取出这个queue中的任务数组，把当前提交的任务添加进去</h3><p>ForkJoinTask&lt;?&gt;[] a &#x3D; q.array;<br>取出这个WorkQueue中的任务数组a<br>初始为null，初始化为8196的数组<br>然后把</p><p>U.putOrderedObject(a, j, task);</p><p>任务放进去<br>java.util.concurrent.ForkJoinPool#signalWork 启动工作线程</p><p>如果没有足够线程，会尝试新建线程<br>java.util.concurrent.ForkJoinPool#tryAddWorker</p><p>在此过程中会把pool传递给thread，然后thread判断queue[]的某个位置是否存在值，若为空则新建queue作为本线程使用的queue(注#1)</p><p>thread在run触发时，实际执行的是</p><p>pool.runWorker(workQueue);<br>然后会尝试获取任务，窃取</p><p>t &#x3D; scan(w, r)<br>使用工作窃取的算法尝试获取任务执行。</p><h1 id="2-signalWork"><a href="#2-signalWork" class="headerlink" title="2.signalWork"></a>2.signalWork</h1><p>很重要的一个方法，所有提交任务的操作后，都会signalWork，动态判断是否要新增线程进行处理。</p><h1 id="3-Fork"><a href="#3-Fork" class="headerlink" title="3.Fork"></a>3.Fork</h1><p>当前执行的线程是ForkJoinThread，直接放在当前线程绑定的queue里，然后通知线程们执行（此处主要是判断线程是否足够）(见注#1)</p><h1 id="4-Join"><a href="#4-Join" class="headerlink" title="4.Join"></a>4.Join</h1><p>tryUnpush会判断该任务是不是在当前thread的队列顶部，如果在队列顶部，该thread会直接进行执行该任务，否则进入wait状态</p><p>所以最顶级的worker按理是不会进行任务窃取的，因为他的任务完成后，其他所有子任务应该都完成了，实际代码运行结果也证实了这个推论</p><p>{ForkJoinPool-1-worker-6&#x3D;63, ForkJoinPool-1-worker-7&#x3D;48, ForkJoinPool-1-worker-0&#x3D;40, ForkJoinPool-1-worker-1&#x3D;1, ForkJoinPool-1-worker-4&#x3D;58, ForkJoinPool-1-worker-5&#x3D;11, ForkJoinPool-1-worker-2&#x3D;32, ForkJoinPool-1-worker-3&#x3D;2}</p><p>ForkJoinPool-1-worker-1为第一个创建的顶级线程（ForkJoinPool-1-worker-0是最后创建的）</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jvm重点小结</title>
    <link href="/2022/12/01/java/jvm%E9%87%8D%E7%82%B9%E5%B0%8F%E7%BB%93/"/>
    <url>/2022/12/01/java/jvm%E9%87%8D%E7%82%B9%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>主要从三个方向：GC、类加载器、并发来总结。</p><h1 id="一、JVM是什么"><a href="#一、JVM是什么" class="headerlink" title="一、JVM是什么"></a>一、JVM是什么</h1><p><img src="/img/java/jvm1.png"></p><p>屏蔽底层具体实现的区别，提供统一的API给开发者使用。</p><p>对于开发者来说，无论是什么平台，实现某一功能的方式完全相同。</p><h1 id="二、JVM内存模型"><a href="#二、JVM内存模型" class="headerlink" title="二、JVM内存模型"></a>二、JVM内存模型</h1><p><img src="/img/java/jvm2.png"></p><h2 id="1-堆（Heap）"><a href="#1-堆（Heap）" class="headerlink" title="1.堆（Heap）"></a>1.堆（Heap）</h2><p><img src="/img/java/jvm3.png"></p><p>堆是gc的主要场所。详情会在后文gc部分描述。</p><h2 id="2-方法区"><a href="#2-方法区" class="headerlink" title="2.方法区"></a>2.方法区</h2><p><img src="/img/java/jvm4.png"></p><p>方法区在1.8之后改名为元数据区</p><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><h2 id="3-虚拟机栈-JVM-Stack"><a href="#3-虚拟机栈-JVM-Stack" class="headerlink" title="3.虚拟机栈(JVM Stack)"></a>3.虚拟机栈(JVM Stack)</h2><p><img src="/img/java/jvm5.png"></p><p>虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈，每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><h2 id="4-本地方法栈-Native-Stack"><a href="#4-本地方法栈-Native-Stack" class="headerlink" title="4.本地方法栈(Native Stack)"></a>4.本地方法栈(Native Stack)</h2><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。</p><p>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。</p><p>甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</p><p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。</p><h2 id="5-程序计数器（PC-Register）"><a href="#5-程序计数器（PC-Register）" class="headerlink" title="5.程序计数器（PC Register）"></a>5.程序计数器（PC Register）</h2><p>在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以每条线程都会有一个独立的程序计数器。</p><p>当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址；如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。</p><p>程序计数器占用的内存空间很少，也是唯一一个在JVM规范中没有规定任何OutOfMemoryError（内存不足错误）的区域。</p><h1 id="三、GC过程"><a href="#三、GC过程" class="headerlink" title="三、GC过程"></a>三、GC过程</h1><h2 id="1-堆结构"><a href="#1-堆结构" class="headerlink" title="1.堆结构"></a>1.堆结构</h2><p><img src="/img/java/jvm6.png"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">分为 年轻代和老年代<br>        年轻代分为 伊甸区和幸存区<br>        每经历一次<span class="hljs-built_in">GC</span>，年龄+<span class="hljs-number">1</span>，<span class="hljs-number">15</span>岁晋升老年代<br>    <span class="hljs-built_in">GC</span>规则为：<br>        Minor <span class="hljs-built_in">GC</span>： 年轻代<span class="hljs-built_in">GC</span><br>            如果年龄大于<span class="hljs-number">15</span>，会上升老年代<br>            如果已经为垃圾对象，清楚<br>            剩下的进入幸存区<br>            若幸存区不够放下此对象，直接晋升老年代<br>          TIPS：动态年龄判断：<br>                    若幸存区中的对象，大于某个年龄的对象大于空间一半，则大于等于该年龄的晋升老年代<br>                空间分配担保：<br>                    如果没开此配置，晋升时会计算历次晋升对象的平均总大小，若大于老年代剩余空间，则进行full <span class="hljs-built_in">GC</span><br>                    若开了 只会进行minor <span class="hljs-built_in">GC</span><br></code></pre></td></tr></table></figure><h2 id="2-如何判断对象是否应该回收"><a href="#2-如何判断对象是否应该回收" class="headerlink" title="2.如何判断对象是否应该回收"></a>2.如何判断对象是否应该回收</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery">古老的：<br>    引用计数法，对象每有一个引用，计数器+<span class="hljs-number">1</span>，收集计数器为<span class="hljs-number">0</span>的对象<br> <span class="hljs-built_in"></span><br><span class="hljs-built_in">root</span>根搜索方法：<br>   <span class="hljs-built_in"> root</span>对象作为起点向下搜索，当一个对象<span class="hljs-built_in">到root</span>没有任何引用链时，可回收。<br>   <span class="hljs-built_in"> root</span>对象：<br>        栈内存中引用的对象<br>        静态或常量引用的对象<br>        被bootstrap加载器加载创建的对象<br>        native方法中JNI引用的对象<br></code></pre></td></tr></table></figure><h2 id="3-垃圾回收算法"><a href="#3-垃圾回收算法" class="headerlink" title="3.垃圾回收算法"></a>3.垃圾回收算法</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">标记-清除：先标记所有被引用的对象，然后再遍历一次将没有标记的清除<br> <br>复制： 内存划分两块。每次使用一块，每次<span class="hljs-built_in">GC</span>，遍历当前区，把被引用的对象复制到另一区。<br> <br>标记-整理：先标记所有被引用的对象，然后遍历删除没有被标记的对象，同时把被标记的对象压缩到一起，按顺序摆放。<br></code></pre></td></tr></table></figure><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4.垃圾回收器"></a>4.垃圾回收器</h2><table><thead><tr><th align="left">名称</th><th align="left">适用范围</th><th align="left">特点</th><th align="left">算法</th></tr></thead><tbody><tr><td align="left">Serial</td><td align="left">年轻代</td><td align="left">单线程、STW</td><td align="left">复制</td></tr><tr><td align="left">Serial Old</td><td align="left">老年代</td><td align="left">单线程、STW</td><td align="left">标记整理</td></tr><tr><td align="left">ParNew</td><td align="left">年轻代</td><td align="left">多线程、与Serial类似</td><td align="left">复制</td></tr><tr><td align="left">Paralle Scavenge</td><td align="left">年轻代</td><td align="left">多线程、吞吐量优先</td><td align="left">复制</td></tr><tr><td align="left">Paralle Ole</td><td align="left">老年代</td><td align="left">多线程、吞吐量优先</td><td align="left">标记整理</td></tr><tr><td align="left">CMS</td><td align="left">老年代</td><td align="left">低停顿</td><td align="left">标记清除</td></tr><tr><td align="left">G1</td><td align="left">全部</td><td align="left"></td><td align="left">局部是复制、整体是标记整理</td></tr></tbody></table><h2 id="5-jdk1-8所使用的垃圾回收器"><a href="#5-jdk1-8所使用的垃圾回收器" class="headerlink" title="5.jdk1.8所使用的垃圾回收器"></a>5.jdk1.8所使用的垃圾回收器</h2><blockquote><p>-XX:+UseParallelGC</p></blockquote><p>使用Paralle Scavenge + Serial Old的组合进行垃圾回收。</p><p><img src="/img/java/jvm7.png"></p><p>在进行GC时会Stop The World。</p><h1 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h1><h2 id="1-类加载过程"><a href="#1-类加载过程" class="headerlink" title="1.类加载过程"></a>1.类加载过程</h2><p><img src="/img/java/jvm8.png"></p><p>简单来说：</p><p>加载：将文件读入内存</p><p>验证：确定class中的信息符合虚拟机要求</p><p>准备：将类变量即静态变量初始化，赋予零值</p><p>解析：将符号引用变为直接引用（指针、相对偏移量或者句柄）</p><p>初始化：执行类构造器，对类变量进行赋予初值</p><h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2.类加载器"></a>2.类加载器</h2><p><img src="/img/java/jvm9.png"></p><p>bootstrap classLoader启动类加载器： 对应安装jre里面的rt.jar包中的类</p><p>extention classLoader 扩展类加载器： 从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库。</p><p>App classLoader 应用类加载器：就是平时写代码，一般都经过应用类加载器。</p><p><strong>双亲委派机制：</strong></p><p>双亲委派机制是<code>指当一个类加载器收到一个类加载请求时,该类加载器首先会把请求委派给父类加载器</code>。</p><p><img src="/img/java/jvm10.png"></p><p>首先判断该类是否已经加载</p><p>未加载判断是否有父加载器，交给父加载器执行</p><p>如果直到Bootstrap 加载器仍未加载过该类，则从上往下加载该类</p><p> 优点：</p><p>1.避免了类的重复加载</p><p>2.保护了程序的安全性，防止核心的API被修改</p><h1 id="五、高效并发"><a href="#五、高效并发" class="headerlink" title="五、高效并发"></a>五、高效并发</h1><h2 id="1-内存访问规则"><a href="#1-内存访问规则" class="headerlink" title="1.内存访问规则"></a>1.内存访问规则</h2><p><img src="/img/java/jvm11.png"></p><p>java变量都储存在主内存中，每个线程有自己的工作内存，会将使用到的变量拷贝到工作内存中，每个线程只能操作工作内存中的变量，无法直接操作主内存中的变量。</p><h1 id="2-volatile关键字"><a href="#2-volatile关键字" class="headerlink" title="2.volatile关键字"></a>2.volatile关键字</h1><ol><li>线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</li><li>顺序一致性：禁止指令重排序。</li></ol><p>但其无法保证操作的原子性，即无法保证线程安全。</p><p><strong>volatile是如何保证可见性的呢？</strong><br>在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时，会多出lock addl。Lock前缀的指令在多核处理器下会引发两件事情：</p><ol><li><p>将当前处理器缓存行的数据写回到系统内存。</p></li><li><p>这个写回内存的操作会使其他cpu里缓存了该内存地址的数据无效。</p></li></ol><h2 id="3-锁相关"><a href="#3-锁相关" class="headerlink" title="3.锁相关"></a>3.锁相关</h2><p><img src="/img/java/jvm12.png"></p><h2 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h2><p>悲观锁：认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p>乐观锁：</p><p>认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p><p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p>CAS：</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>在进行写入B时判断当前值是否等于A，如果不等于A则不写入。</p><h2 id="自旋锁、适应性自旋锁"><a href="#自旋锁、适应性自旋锁" class="headerlink" title="自旋锁、适应性自旋锁"></a>自旋锁、适应性自旋锁</h2><p>背景：很多场景下，资源被锁定的时间很短，而线程的挂起恢复很耗性能，如果可以以等待合理的时间换来避免线程挂起恢复，可能性能更优。</p><p>自旋锁：在尝试获取锁失败时不放弃CPU时间片，尝试等待锁释放。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p><img src="/img/java/jvm13.png"></p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h2 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h2><p><img src="/img/java/jvm14.png"></p><p>当只有一个线程访问时，会使用偏向锁，不做同步处理。</p><p>当再有线程访问时，就会升级为轻量级锁，自旋使用CAS来获取锁。</p><p>当竞争大到一定程度就会升级为重量级锁，未获取锁的线程就会进入阻塞态。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志框架——以Slf4j为核心</title>
    <link href="/2022/10/11/java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E4%BB%A5Slf4j%E4%B8%BA%E6%A0%B8%E5%BF%83/"/>
    <url>/2022/10/11/java/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E4%BB%A5Slf4j%E4%B8%BA%E6%A0%B8%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p>slf4j是门面模式的日志框架，本身不含有日志模块的实现，而是提供了上层的抽象，下层具体实现交由各个日志组件实现。</p><p>正常来说是：slf4j + 某一款日志组件 +（可选：适配包）</p><p>如果项目中本来已经使用了某款日志组件，比如说依赖包里绑定了log4j，而自己的项目要使用logback，那么需要使用适配包将log4j的日志委托给slf4j，再由slf4j调用logback实现日志。</p><table><thead><tr><th align="left">日志框架</th><th align="left">被桥接包（即交给slf4j）</th><th align="left">桥接包（即slf4j使用该日志框架实现功能）</th></tr></thead><tbody><tr><td align="left">JUI</td><td align="left">jul-to-slf4j</td><td align="left">slf4j-jdk14</td></tr><tr><td align="left">JCL</td><td align="left">jcl-over-slf4j</td><td align="left">slf4j-jcl</td></tr><tr><td align="left">log4j</td><td align="left">log4j-over-slf4j</td><td align="left">slf4j-log4j12</td></tr><tr><td align="left">log4j2</td><td align="left">log4j-to-slf4j</td><td align="left">log4j-slf4j-impl</td></tr><tr><td align="left">logback</td><td align="left">自动适配</td><td align="left">自动适配</td></tr></tbody></table><p>注意，被桥接包和桥接包不能同时使用</p><p>比如</p><table><thead><tr><th>jul-to-slf4j</th><th>slf4j-jdk14</th></tr></thead></table><p>同时存在，意味着，你把JUI打印日志交给Slf4j，由让Slf4j使用JUI进行日志打印。产生循环会冲突</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo日志体系</title>
    <link href="/2022/09/29/dubbo/dubbo%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB/"/>
    <url>/2022/09/29/dubbo/dubbo%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/dubbo/dubbo%E6%97%A5%E5%BF%97.png"></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 1c">logger<br>jcl                       <span class="hljs-string">|</span><br>jdk                       <span class="hljs-string">|</span><br>log4j                     <span class="hljs-string">| 对几个常用日志框架的适配，见下文</span><br>log4j2                    <span class="hljs-string">|</span><br>slf4j                     <span class="hljs-string">|</span><br>support 将日志打印封装进来，不打印报错信息<br>Level<br>Logger     相关抽象接口以及获得logger的入口<br>LoggerAdapter<br>LoggerFactory<br></code></pre></td></tr></table></figure><p>入口：LoggerFactory<br>从系统变量获取要加载的日志框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-comment">//静态代码块，从系统变量获得要加载的日志框架</span><br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;dubbo.application.logger&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">switch</span> (logger) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;slf4j&quot;</span>:<br>            setLoggerAdapter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLoggerAdapter</span>());<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jcl&quot;</span>:<br>            setLoggerAdapter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JclLoggerAdapter</span>());<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;log4j&quot;</span>:<br>            setLoggerAdapter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log4jLoggerAdapter</span>());<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jdk&quot;</span>:<br>            setLoggerAdapter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkLoggerAdapter</span>());<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;log4j2&quot;</span>:<br>            setLoggerAdapter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Log4j2LoggerAdapter</span>());<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br><br><span class="hljs-comment">//如果没配置，或按下列顺序一个一个加载，直到第一个成功加载为止</span><br>            List&lt;Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LoggerAdapter</span>&gt;&gt; candidates = Arrays.asList(<br>                    Log4jLoggerAdapter.class,<br>                    Slf4jLoggerAdapter.class,<br>                    Log4j2LoggerAdapter.class,<br>                    JclLoggerAdapter.class,<br>                    JdkLoggerAdapter.class<br>            );<br>            <span class="hljs-keyword">for</span> (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LoggerAdapter</span>&gt; clazz : candidates) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    setLoggerAdapter(clazz.newInstance());<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>                &#125;<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从配置中获得要加载的框架</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void set<span class="hljs-constructor">LoggerAdapter(String <span class="hljs-params">loggerAdapter</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (loggerAdapter != null<span class="hljs-operator"> &amp;&amp; </span>loggerAdapter.length<span class="hljs-literal">()</span> &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">//使用dubbo的SPI加载对应的日志框架</span><br>set<span class="hljs-constructor">LoggerAdapter(ExtensionLoader.<span class="hljs-params">getExtensionLoader</span>(LoggerAdapter.<span class="hljs-params">class</span>)</span>.get<span class="hljs-constructor">Extension(<span class="hljs-params">loggerAdapter</span>)</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对不同日志框架的适配<br>以Slf4j为例</p><p>Slf4jLoggerAdapter<br>创建对应Logger的封装类，比如Slf4j的为Slf4jLogger（见下文），本类中主要处理不同日志框架的不同创建方法，然后用封装类封装后返回，以及处理日志等级，获取logger打印文件（只有log4j和jdk自动获取了文件）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Slf4jLoggerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoggerAdapter</span> &#123;<br><br><span class="hljs-keyword">private</span> Level level;<br><span class="hljs-keyword">private</span> File file;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Logger <span class="hljs-title function_">getLogger</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>(org.slf4j.LoggerFactory.getLogger(key));<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Logger <span class="hljs-title function_">getLogger</span><span class="hljs-params">(Class&lt;?&gt; key)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>(org.slf4j.LoggerFactory.getLogger(key));<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Level <span class="hljs-title function_">getLevel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> level;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLevel</span><span class="hljs-params">(Level level)</span> &#123;<br>    <span class="hljs-built_in">this</span>.level = level;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> File <span class="hljs-title function_">getFile</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> file;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFile</span><span class="hljs-params">(File file)</span> &#123;<br>    <span class="hljs-built_in">this</span>.file = file;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Slf4jLogger<br>可以看到，就是一个装饰器模式的封装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Slf4jLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Logger</span>, Serializable &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">FQCN</span> <span class="hljs-operator">=</span> FailsafeLogger.class.getName();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> org.slf4j.Logger logger;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LocationAwareLogger locationAwareLogger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Slf4jLogger</span><span class="hljs-params">(org.slf4j.Logger logger)</span> &#123;<br>    <span class="hljs-keyword">if</span> (logger <span class="hljs-keyword">instanceof</span> LocationAwareLogger) &#123;<br>        locationAwareLogger = (LocationAwareLogger) logger;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        locationAwareLogger = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-built_in">this</span>.logger = logger;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.TRACE_INT, msg, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.trace(msg);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(Throwable e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), <span class="hljs-literal">null</span>, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.trace(e.getMessage(), e);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(String msg, Throwable e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.TRACE_INT, msg, <span class="hljs-literal">null</span>, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.trace(msg, e);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.DEBUG_INT, msg, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.debug(msg);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(Throwable e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), <span class="hljs-literal">null</span>, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.debug(e.getMessage(), e);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg, Throwable e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.DEBUG_INT, msg, <span class="hljs-literal">null</span>, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.debug(msg, e);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String msg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.INFO_INT, msg, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.info(msg);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(Throwable e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), <span class="hljs-literal">null</span>, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.info(e.getMessage(), e);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String msg, Throwable e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.INFO_INT, msg, <span class="hljs-literal">null</span>, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.info(msg, e);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">warn</span><span class="hljs-params">(String msg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.WARN_INT, msg, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.warn(msg);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">warn</span><span class="hljs-params">(Throwable e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), <span class="hljs-literal">null</span>, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.warn(e.getMessage(), e);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">warn</span><span class="hljs-params">(String msg, Throwable e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.WARN_INT, msg, <span class="hljs-literal">null</span>, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.warn(msg, e);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.ERROR_INT, msg, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.error(msg);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">error</span><span class="hljs-params">(Throwable e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), <span class="hljs-literal">null</span>, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.error(e.getMessage(), e);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">error</span><span class="hljs-params">(String msg, Throwable e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locationAwareLogger != <span class="hljs-literal">null</span>) &#123;<br>        locationAwareLogger.log(<span class="hljs-literal">null</span>, FQCN, LocationAwareLogger.ERROR_INT, msg, <span class="hljs-literal">null</span>, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    logger.error(msg, e);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTraceEnabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> logger.isTraceEnabled();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebugEnabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> logger.isDebugEnabled();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInfoEnabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> logger.isInfoEnabled();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isWarnEnabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> logger.isWarnEnabled();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isErrorEnabled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> logger.isErrorEnabled();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo服务注册和发现、调用</title>
    <link href="/2022/08/16/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E3%80%81%E8%B0%83%E7%94%A8/"/>
    <url>/2022/08/16/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E3%80%81%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E3%80%81%E5%8F%91%E7%8E%B0%E3%80%81%E8%B0%83%E7%94%A8.png"></p>]]></content>
    
    
    <categories>
      
      <category>dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
